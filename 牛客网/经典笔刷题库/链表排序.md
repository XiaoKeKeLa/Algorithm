

**链表排序**

https://www.nowcoder.com/practice/d75c232a0405427098a8d1627930bea6?tpId=46&&tqId=29033&rp=1&ru=/ta/classic-code&qru=/ta/classic-code/question-ranking

题目描述

在O(n log n)的时间内使用常数级空间复杂度对链表进行排序。

示例1

输入

```
{30,20,40}
```

输出

```
{20,30,40}
```

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */
//归并排序
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    ListNode* sortList(ListNode* head) {
        // write code here
        if(head==NULL || head->next==NULL) return head;
        ListNode* slow = head;
        ListNode* fast = head->next;
        while(fast!=NULL)
        {
            fast = fast->next;
            if(fast==NULL) break;
            fast = fast->next;
            slow = slow->next;
        }
        ListNode* list1 = head;
        ListNode* list2 = slow->next;
        slow->next = NULL;
        ListNode* left = sortList(list1);
        ListNode* right = sortList(list2);
        return merge(left, right);
    }
    
    ListNode* merge(ListNode* left, ListNode* right) //合并
    {
        ListNode* outres; //设置结果的表头
        if(left->val < right->val)
        {
            outres = left;
            left = left->next;
        }
        else
        {
            outres = right;
            right = right->next;
        }
        ListNode* p = outres;
        p->next = NULL;
        while(left && right)
        {
            if(left->val < right->val)
            {
                p->next = left;
                left = left->next;
                p = p->next;
                p->next = NULL;
            }
            else
            {
                p->next = right;
                right = right->next;
                p = p->next;
                p->next = NULL;
            }
        }
        if(left!=NULL) 
        {
            p->next = left;
        }
        else
        {
            p->next = right;
        }
        return outres;
    }
};






```

